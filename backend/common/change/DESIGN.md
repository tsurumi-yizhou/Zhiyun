# CRDT 更改文件系统设计文档

## 概述

这是一个基于 CRDT（Conflict-free Replicated Data Types）的分布式更改文件系统，旨在支持多 Agent 并发协作的场景。系统通过版本化的变更记录和可合并的线程模型，实现无冲突的分布式状态同步。

## 核心设计目标

1. **多 Agent 并发协作**：多个 Agent 可以同时工作，无需中心协调
2. **无冲突合并**：基于 CRDT 的自动冲突解决机制
3. **版本化历史**：完整保留所有变更历史
4. **实时快照**：支持编辑器实时查看任意线程的状态
5. **可分叉线程**：支持线程的分叉与合并

## 核心概念

### Thread（线程）

Thread 是一组有序的变更序列，代表一个独立的工作流：

- **独立性**：每个 Thread 独立演进，互不干扰
- **可分叉性**：可以从任意点创建新的 Thread 分支
- **可合并性**：多个 Thread 可以合并成新的 Thread
- **版本化**：Thread 上的每个操作都带版本标识

### Change（变更）

Change 是系统最小的操作单元：

- **原子性**：每个 Change 是原子的，不可分割
- **版本标识**：通过唯一 ID 和逻辑时间戳标识
- **可追溯**：每个 Change 记录其前置依赖
- **类型化**：支持不同类型的变更操作（如插入、删除、更新等）

### Snapshot（快照）

Snapshot 是 Thread 在某个版本的完整状态：

- **实时计算**：基于 Change 序列即时生成
- **增量更新**：支持高效的增量计算
- **多版本**：可同时存在多个版本的快照

## 系统架构

### 分层设计

```text
┌─────────────────────────────────────┐
│         编辑器视图层                  │
│    (实时显示 Snapshot)               │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│       Thread 管理层                  │
│  (Thread 创建、分叉、合并)            │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│       Change 存储层                   │
│  (Change 持久化、索引)               │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│       CRDT 合并引擎                   │
│  (冲突检测、自动合并)                 │
└─────────────────────────────────────┘
```

## 关键机制

### Thread 分叉

从现有 Thread 的任意版本点创建新 Thread：

1. 选择父 Thread 的某个版本作为分叉点
2. 创建新的 Thread，继承该版本的所有历史 Change
3. 新 Thread 可独立演进，不影响父 Thread

### Thread 合并

合并两个或多个 Thread 的变更：

1. 找到各 Thread 的最近公共祖先
2. 基于 CRDT 算法自动合并冲突
3. 生成合并后的新 Change 序列
4. 创建包含所有变更的合并 Thread

### 版本标识

每个 Change 通过以下方式唯一标识：

- **Change ID**：全局唯一的标识符（如 UUID）
- **Vector Clock**：向量时钟用于确定因果关系
- **Parent References**：指向直接前置 Change 的引用

## 数据模型

### Change 结构

```text
Change
├── id: ChangeId
├── timestamp: DateTime
├── parents: List<ChangeId>
├── author: AgentId
├── operation: Operation
└── metadata: Map<String, Value>
```

### Thread 结构

```text
Thread
├── id: ThreadId
├── head: ChangeId        // 当前最新的 Change
├── fork_point: ChangeId  // 分叉点（如果是分支）
└── metadata: ThreadMetadata
```

## 并发控制

### 因果关系

使用向量时钟追踪变更之间的因果关系：

- 如果 Change A 依赖 Change B，则 A 的向量时钟 > B 的向量时钟
- 如果两个 Change 的向量时钟不可比较，则它们是并发的

### 冲突解决

对于并发的冲突变更：

1. **操作转换**：将冲突操作转换为兼容的形式
2. **最后写入胜出**：对于简单类型，使用时间戳决定
3. **语义合并**：根据操作类型进行智能合并

## 快照生成

### 实时快照计算

1. 从 Thread 的 head 开始
2. 逆向遍历 Change 序列到根
3. 按顺序应用所有 Change 操作
4. 生成最终状态

### 增量优化

- 缓存已计算的中间状态
- 仅应用新增的 Change
- 使用增量更新算法

## 应用场景

### 多 Agent 协作编辑

- 每个 Agent 有独立的 Thread
- 定期合并各 Agent 的 Thread
- 实时显示合并后的状态

### 实验性分支

- 从主 Thread 分支创建实验 Thread
- 在实验 Thread 中进行修改
- 审核后合并回主 Thread

### 并行任务执行

- 不同 Agent 在不同 Thread 上执行任务
- 收集各 Thread 结果并合并

## 存储考虑

### Change 存储

- 每个 Change 独立存储
- 使用 Change ID 作为索引
- 支持高效的遍历查询

### Thread 元数据

- 存储 Thread 的 head 指针
- 记录分叉关系
- 维护 Thread 之间的引用图

## 可扩展性

### 支持的 Change 类型

- 文本编辑（字符级）
- 结构化数据（JSON、YAML）
- 代码变更（AST 级别）
- 文件系统操作

### 自定义操作

允许扩展新的操作类型：

- 定义操作的语义
- 实现操作的合并逻辑
- 注册到 CRDT 引擎

## 限制与权衡

1. **存储开销**：保存所有 Change 会增加存储需求
2. **计算成本**：快照生成需要遍历完整历史
3. **合并复杂度**：复杂操作的合并可能需要领域特定逻辑

## 未来方向

1. 支持 Change 的压缩和垃圾回收
2. 实现更高效的增量快照算法
3. 添加可视化工具展示 Thread 分支图
4. 支持跨网络同步和分布式部署
